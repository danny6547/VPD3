insertDNVGLIntoRaw: test          
# sortOnDateTime: test              
# updateAirDensity: test            
# updateBrakePower: test            
# updateDisplacement: test          
# updateExpectedSpeed: test         
# updateMassFuelOilConsumed: test   
# updateShaftPower: test            
# updateSpeedLoss: test             
# updateWindResistanceCorrection: test     
# updateWindResistanceRelative: test     
# updateAirResistance: test     
# updateTransProjAreaCurrent: test
# updateCorrectPower: test     
# updateWindResistanceCorrection: write   
# updateAirResistance: write     
# updateCorrectPower: write       
# updateAirDensity: write            
# updateBrakePower: write            
# updateDisplacement: write          
# updateExpectedSpeed: write         
# updateMassFuelOilConsumed: write   
# updateShaftPower: write            
# updateSpeedLoss: write        
ISO19030: test
ISO19030: write
# updateDeliveredPower: test
# updateDeliveredPower: write
# isShaftPowerAvailable: test
# isShaftPowerAvailable: write
# isBrakePowerAvailable: test
# isBrakePowerAvailable: write
# convertDNVGLRawToRawData: write
insertDNVGLIntoPerformance: test
insertDNVGLIntoPerformance: write
# updateExpectedSpeed: include conditions for admiralty formula
# updateExpectedSpeed: include conditions for admiralty formula, test
# updateExpectedSpeed: include conditions for admiralty formula, write
insertIntoSpeedPowerCoefficients: calculate R2 value and validate against ISO standard (0.8)
# updateAirResistanceNoWind: find coefficient in bin containing direction zero (create BinCentres Column in WindCoefficientDirection?)
createRawData: modify double precision to reflect real-world values
updateBrakePower: allow for multiple engines per IMO
bunkerDeliveryNote: make BDN_number unique. This will both ensure that no duplicates rows are added when adding notes from different ships, and that only one value can be indexed for raw data.
# updateLCVFuelOil: test
# updateLCVFuelOil: write
insertWithoutDuplicates: test
# insertWithoutDuplicates: write
# updateLCVFuelOil: rename to updateFromBunkerNote, include update of density value
# removeInvalidRecords: test for remove rows where: mfoc is zero,
# removeInvalidRecords: write
updateBrakePower: make compatible with arbitrary-frequency data
# removeFOCBelowMinimum: remove values of Mfoc below the minimum FOC of the SFOC reference curve.
# deleteWithReferenceConditions: test remove values corresponding to those failing the reference conditions in the standard.
# deleteWithReferenceConditions: write
# insertBunkerDeliveryNoteDNVGL: write
insertBunkerDeliveryNoteDNVGL: test

# filterSpeedPowerLookup: update displacement and trim filters for speed-power values
# filterSpeedPowerLookup: test
# filterSpeedPowerLookup: write
# vessels: column "Speed Power Source", where data was sourced from.
# updateExpectedSpeed: test for multiple-displacement power curves
# updateExpectedSpeed: write for multiple-displacement power curves
Vessels.Speed_Power_Source: what if file is moved? Generate ordered, protected, easily expandable dir structure.
# sensorRecalibration: create table for dates and nature of sensor recalibration (imo, sensor, description)
# filterPowerBelowMinimum: filter values of Delivered Power below the minimum power of the speed-power curve.
# filterPowerBelowMinimum: test
# filterPowerBelowMinimum: write
# normaliseFrequencies: update all columns by normalising frequencies based on formula 2.
# normaliseHigherFreq: average higher-freq data to a lower frequency
# normaliseHigherFreq: write
# normaliseHigherFreq: test
# normaliseLowerFreq: duplicate lower-freq data to a higher frequency
# normaliseLowerFreq: write
# normaliseLowerFreq: test
# updateChauvenetsCriteria: mark rows for filtering for non-angle variables.
# updateChauvenetCriteria: calculate mean and error of angles from formula I2.
# validteData: applies formulae in annex J
# validteData: test
# validteData: write
# validteData: update for standard error of angles calculations

# Sensors: create table to store sensors and their accuracies
# ISO19030Compliant: create table to store boolean indicating whether analysis was compliant with standard
# checkSensorRequirements: (validateFrequencies) insert value for column "Compliant" into table ISO19030Compliant based on comparison of values in Sensors and the requirements in the standard

# PerformanceData: rename to PerformanceDataDNVGL
? PerformanceDataISO19030: create table for data processed from ISO19030
# insertPerformanceDataISO19030: insert performance data derived from RawData into PerformanceDataISO19030 (insertIntoPerformanceData)

propulsiveEfficiency: figure out how to calculate EtaD for "calm" and "actual voyage" conditions

? staticShip: insert static ship data ie speed-power, LBP, (table vessels works for now)
updateKPI: calculate dd performance, in-service performance (out of scope of this project?)

# Find script behind procedure addTimeDNVGLRaw;
? Delete table DNVGLRaw, rewrite loadInfileDNVGLRaw to load data into tempRaw, make ready for RawData, insert without duplicates to RawData;
# updateWindResistanceCorrection: make select from speedPower table based on IMO (EtaD, TA, Crw, C0w)
# call filtering and outlier finding procedures from ISO19030 procedure.

# FiltSPDispTrim: should be true if either Disp or Trim is true?
# FiltSPBelow: currently all NULL
# CauvenetFilt: all NULL
# Validated: all NULL
# AllFilt: all NULL
# Check all tested procedures are called from ISO19030.
	# call updateAirDensity before updateAirResistanceNoWind and updateWindResistanceRelative
	# call updateTransProjArea before updateWindResistanceRelative and updateAirResistanceNoWind
	# call updateFromBunkerNote before updateMassFuelOilConsumed
	# call deleteWithReferenceConditions
	# call deleteWithReferenceConditions
	# call normaliseHigherFreq
	# call normaliseLowerFreq
	# call updateChauvenetCriteria
	# call updateValidated
# Create naming convention for filter columns. (all start with Filter_)
Create matrix of vessels, filter columns.
# updateFromBunkerNote: if no data found, assign defaults
removeInvalidRecords: check for entirely NULL rows ?
# removeFOCBelowMinimum, filterSFOCOutOfRange: change from DELETE to new filter column
# deleteWithReferenceConditions: change from DELETE to new filter column
# insertFromDNVGLRawIntoRaw: reduce run time to less than 1s. (1.4s, close enough)
# ChauvenetFilt: verify no change after data with too-high frequency input, standard compliance updated
# Validated: verify no change after data with too-high frequency input, standard compliance updated


# Pull "Vessel Performance" into Database repo, copy methods into cV (history
# of cVA will exist in repo along with others, but won't "follow" the 
# methods from one file to the other. Commit message stating that methods 
# are being moved will have to do).
# Copy methods from cVA to cV
# Copy methods from cHPDB to cV
	Both methods return cV array, either row vect if no DD data in DB or 
	matrix otherwise
# Create property DryDockInterval for cV
# Write iteration methods for cV
# Replace existing iteration calls with new ones
# Write constructor sub call to detect file inputs or IMO inputs
# Write cV.loadFilePerformance (ended up as loadDNVGLPerformance)

updateFromBunkerNote: Include warnings if some BDN numbers not found in BunkerDeliveryNote table?
Extract "timestep" into high-level metadata table

# Organise repository:
	# Tidy up folders
	# Remove redundant files
	# Remove redundant procedures
	# Remove redundant tables
	# Rename database
# Investigate withoutDuplicates performance issues (replace with unique constraints)
# Duplicate rows:
	# Issue where insertFromDNVGLRawIntoRaw will insert duplicates if given
	# Requirements for data returned when duplicate inserts attempted: all transactions logged somewhere? row numbers returned in output?
	# Requirements for detection of data duplication:
		If duplicates detected on key columns, can we see when other columns are different? Yes, ROW_COUNT after on duplicate key update = 0 when no change, = N when N rows changed.
		# Negative consequences of puttin unique key contraints on only IDENTIFYING columns (ie IMO, Time)? This would allow updating the non-key columns, otherwise deletion necessary. 
		# Replace withoutDuplicates syntax with unique constraints
			# Drop rawdata, write constraint into create script
			# Drop dnvglraw, write constraint into create script
			# Drop performanceData, write constraint into create script
			# Drop DNVGLperformanceData, write constraint into create script
			# Replace insertWithoutDuplicates with new cMySQL
			# Rewrite insertFromDNVGLRawIntoRaw to call ON DUPLICATE KEY UPDATE
			# Rewrite insertIntoPerformanceData to call ON DUPLICATE KEY UPDATE
	Performance comparison with alternatives
# Access database:
	# from external machince
	# via internet

# Finalise processing of data from various sources:
	# Write remainder of MATLAB code: insertIntoSFOCCoefficients, insertIntoOthers
	# Write single-call procedure for ISO on raw, insert into performance
	
# Implement Annex E to go from annemometre-height wind to reference-height wind
# Rename "Database" to "Vessel Performance Database"

# Convert insertIntoTable into cMySQL method
removeNullRows: set filter for rows where any primary or secondary parameter is NULL
# Write ON DUPLICATE KEY UPDATE calls into tables:
# 	BunkerDeliveryNote
# 	DryDockDates
# 	SFOCCoefficints
# 	SpeedPower
# 	SpeedPowerCoefficients
# 	VesselCoating
# 	Vessels
# 	windcoefficientdirection: Unique(imo, start direction) and Unique(imo, end direction)
	
insertBunkerDeliveryNoteDNVGL: convert from function to method of cVesselDB, use insertDuplicate
# rename table PerformanceDataDNVGL to DNVGLPerformanceData
create high-level table for "meta-data" of performance data
# remove table "ships", replace relevant data into "vessels"
# Write "use hull_performance" at start of all files
# Procedure to call ISO19030 with input filters, add data to performance.
# Allow MATLAB table output from SQL queries
# Write code for (re-)building DB from downloaded files
Write timestep into metadata table for each vessel, parameter

# Apply appropriate iteration to methods:
#  regressions
#  movingAverages

# cVA.filterOnUniqueIndex: allow only unique values, remove corresponding 
# non-unique values in other variables
Store variable names defined for files
isFileDNVGLRaw: detect if file contains data from DNVGL "Manage Data"
isFileDNVGLProcessed: detect if file contains data from EI widgets
fileTypes: function to determine type of each element of cellstr FILENAME
# loadDNVGLRaw: return IMO of contained vessels as additional output
cMySQL.executeIfOneOutput: modify to (include) zero output, if class 
	remains handle.
# cVessel.readFromVessels: populate data from table "vessels"
# cVessel.readFromTable: match object properties to table columns
cV.constructor: error if one name and multiple imo input
# cV.iterReset: if finished, reset Iter to zero
cV.cV: include input to specify loading function
# write cV.iterReset after all while ~obj.iterFinished so that cV can be 
# 	value class again.
# cVessel.insertIntoTable: match object properties to table columns
executeIfOneOutput: replace third (optional) input with something sensible
performanceData: bug where multiplie structs returned when duplicate IMO input

Should vessel speed, power data be nested in property SpeedPower?
cV.iterDD: error when only one DD interval
# cV.ServiceInterval: make same as struct output by method
cV.annualSavingsDD: method should iterate over dry dockings and vessels.
cV.cV: error when DNVGL speed and per index files input together
# cV.cV: fix bug where different number of DDIs leads to error
annualSavingsDD: error when activity vector doesn't match size of object
annualSavingsDD: calculate differently if variable speed index
# insertIntoSFOCCoefficients: call insertIntoTable
# make cSpeedPower a handle.
# make cV.SP only accept handles.
# Write properties Speed, Power, Draft, Trim etc for cV (dependent, maybe hidden)
# Write get methods for Speed, Power etc to obtain (equal-length) vectors
# cV.insertIntoSpeedPower: now needs only work on cV
# cSP.Speed, Power ... : make vectors
# cSP.Speed, Power: make vectors of the same length
# cSP.Draft, Trim: make scalars
cV.Speed_Power_Source: make dependent
cV.get.Speed_Power_Source: return cellstr vector with values for all SP, all OBJ
# cV.insertIntoSpeedPower: make cV method work on arrays of cV and of cSP
# cV.insertIntoSpeedPowerCoefficients: make cV method work on arrays of cV and of cSP
cMySQL.readTable: output table from input name, columns, order, limit (ie SELECT inputs)
# cV.insertIntoWindCoefficient: 
DB: document units of manually-added table data
# cV.PerformanceTable: string restricted to names of DB tables.
cV.performanceData: read data for PerformanceTable table
cV.PerformanceIndex: refresh when PerformanceTable changes value
cV.InsertRaw: MATLAB raw data insert function (a function with inputs for IMO,
 STW, SOG, Torque etc which writes into table RawData, warning user to 
 check units etc
# ISOProcess.sql: SQL procedure to extract relevant raw data, run iso with 
#  default filters, insert results into PerformanceData.
# DB: make engine_model of SFOCCoefficients unique
# DB: Document unknowns with ship model data (e.g. the Man Engine data, is SFOC curve dependent on num cylinders?)
# DB: recreate table windcoefficientdirection, now with only columns modelID, Direction, Coefficient
# updateWindResistance: find nearest to measured direction
# cVWC.extend360: rotate angular vectors by 180 degrees to cover full circle
# cV.insertIntoSPC: method to write coefficient data into table
# cVSP.fit: method to fit data to regression
# cVWC.nextModelID: get next highest unique index
# cVWC: hide inherited properties
# DB.insertIntoWind: autoincrement the modelID field when input value is empty
# cV.insertIntoWindCoeff: call DB.insertIntoWind in loop
# DB: replace IMO_Vessel_Number in speedPowerCoefficients table with ModelID
# cVWC.incrementModelID: check if exact values found in DB and assign values accordingly
# DB: make the following table: columns non-null
#	SpeedPower: IMO
#	Vessels: IMO
# DB.createTable_: write procedure from each create table script
# DB.createTables: create all tables by calling all create table procedures
# cDB.create(dbname): static method which calls createTables.sql, loads all raw and processed data into tables.
# cDB.createTest: calls cDB.create(test)
# cDB.createHullPer: calls cDB.create(hull_performance)
# cConnectMySQLDB.test: change name of test DB from 'test2' to 'test'
# DB: rebuild (some of the) DDDates and VesselCoating tables
cVessel: intended to be arrays of cV, but inherited class cMySQL intended to work on scalars. Should cMySQL methods call only the first object in array?
cV.performanceData: error when vessel (cassiopiea) has no dry-dock data
cV.DryDockings: property dependent on DryDockDates
# cV.fitToData(struct): hidden, private method to repeat existing rows of obj so that struct data can now fit into it
# cV.assignPerformanceData: hidden private method taking object array of appropriate size
cV.set.PerformanceTable: get performance struct with same parameters as before, call fitToData, assign data.
# DB: write procedure updateWindReference
# DB: include Relative_Wind_Direction_Reference column in tempRawISO
# DB: include Relative_Wind_Speed_Reference column in tempRawISO
# DB: Where are speed, power coefficients being used?
# cV.assignPerformanceData: sort out problem where field names have to be lower case
DB: "NearestDisplacement" and "NearestTrim" can be misleading, as they can come from different speed, power curves.
cDB: implement table vesselcoatings in cDB, creating and writing CMA data
# cDB: add 4 standard wind coefficient sets
# DB: calculate wind resistance correction on relative wind at reference
# DB: correct for environmental conditions prior to speed, power lookup
vesselName: remove hard-coded connection details (make cV method?)
updateAirResistanceNoWind.sql: take coefficient where direction covers 0.
# speedPowerCoefficients: include CoefficientC column, replace ExponentA, B with Coeff_
# speedPower, speedPowerCoefficients: replace IMO_Vessel_Number columns, properties with spModel
DB: rebuild with externally validated scripts
# cDB: include dry dock dates file
cV.inServicePerformance: return in-service performance value by subtacting averages
cV.dryDockingPerformance: rename to DryDockingImprovement (or something)
cV.dryDockingPerformance: calculate as described in ISO
cV.DryDockingImprovement: return struct same size as cV?
DB: download all raw from DNVGL again (for the final time), rewrite loadDNVGLRaw to parse new format
cV: the following code deletes connections of all but first vessel vess(n).SpeedPower(m) = vessSP;
# cVSP, cVWC: multiple objects can have the same ModelID when both instantiated without writing to DB.
# 	cMID: when any data assigned to properties (other than ModelID), get next modelID, assign, write modelID into DB.
# 	cMID: on deletion, if properties matching those of table are empty in OBJ and DB, remove modelID from DB
# cDB: add updateDefaultValues to list of procedures.
# cDB: add createVesselSpeedPowerModel to list of procedures.
# cVSP: write to VesselSpeedPowerModel when insert called.
# cDB: add updateWindReference to list of procedures.
updateWindReference: test and update to match results from DIGU script
# cModelID: adds duplicate rows to table 
# cVSP: insert value into speedpowermodel table
updateExpectedSpeed.sql: why do negative coefficients lead to invalid results?
MATLAB: how to instantiate the calling class as an array?
cVSP: bug where Coefficients may not match those of the S, P data if the data is changed after fitting
cVSP: allow user to select units of input
cMySQL: allow for alias inputs between object properties and column names
cVSP.copy: copy data and modelID, leave IMO_Vessel_Number blank
Chauvenet_Criteria: set false when timestep less than 5 mins?
# updateWindResistance: IFNULL on propulsiveEfficiency 
updateReferenceConditions: depth and wind inaccurate?
check results for Filter_Speed_Above_Max, below (seem to be different)
DB: createFilterTable to store numbers of data removed per filter for each analysis 
# cV.loadDNVGLReportingFormat: load from xlsx
# cV.loadXLSX(file, fileColID, tabColNames): load from xlsx by associating file column names or indices with table column names
# DB: ensure vessel input scripts in sync with ModelID values. Allow models to be assigned by Name?
cV.ISO19030: write GUI filter selector
# cDB: add UASC, AMCL analyses to create?
cV.insertDataDuplicate: call either insertValuesDuplicate or loadInFileDuplicate on a new text file depending on data size.
Are noon-report drafts measured off draft-markings or corrected to perpendiculars?
# Specify units of displacement in displacement table (m3 or tn)? m3!
cVSP.Rho: water density used in calculation of displacement in model data.
cVSP.Displacement: change values depending on that of Rho.
DB: sp, spc: change units of Displacement column to m3
DB: rewrite insert_data scripts to account for fluid density.
updateDisplacement: remove conversion from volume to mass
New Vanguard: Many Displacement not being read from file after DB rebuilt home 280717.
Return data identifying which data was inserted after any insert statement into time-series tables
DB: Include sister ships information
# DB: Change Compliance table name to Analysis, include Comment TEXT column
DB: Create table Filters, with column for IMO, DateTime and all filters cols in tempRawISO
DB: Create table KPI: IMO, StartDate, EndDate, KPI (in-service, DD, trigger, effect), Value
# cV.ISO19030: implement all filters in inputs
# DB: Sort out ModelID 
# Insert_data: allow scripts to be "called" within function while allowing database selection.
Allow Vessels not in DB to be created via 'IMO' input.
tempRawISO: Create tempRawISO columns Filter_SFOC_Below, Filter_SFOC_After
# applyFilters.sql: return table of IMO, Date, Speed_Index after apply all filters form Filter table
# insertIntoPerformanceData.sql: call applyFilters in final insert statement
cV.updateFilters: include disp and trim widths
filterSpeedPowerLookup: include disp widths as input
updateNearestTrim: include trim widths as input
updateFilters: include iteration over OBJ, where each OBJi can have a corresponding threshold value.
insertIntoPerformanceData: include additional outputs, time and performance data array
cV.applyFilters: take same inputs as cV.ISO19030, call updateFilters, call applyFilters.sql, call assignPerformanceData
ISO19030.sql: NULL values for columns lead to TRUE values for filter columns (e.g. no displacement data, so filter based on speed, power condition).
ISO19030.sql: error when insufficient static vessel data found
cModelID: "empty" row of data left in table after data inserted.
DB: copy the contents of files from AMCL which give "update links?" prompt, interrupting calling function
DB: find cause of NULL values for performance values in performanceData 
cMySQL.loadInFile: replace two set inputs with one cellstr of set statements
cDB.create: return warnings from SQL load in file commands to make user aware of any possible failure to read files
DB: remove "block coefficient" from Vessels table
cV, cVC: remove property Block Coefficient
loadXLSX: document
# loadXLSX: create "nullif" command for all table columns not in inputs
# loadXLSX: create statements to set NaN to NULL
DB: implement reference condition for true wind speeds above Beaufort 4
cVSP.Speed: document units of knots
cVSP.Power: document units of kW
cVSP.Displacement: document units of tons
cVSP.FluidDensity: new property giving the density at which the Displacement was calculated
# cVSP.insert: change displacement to m^3
Acquire Adjunct to D1250-08 and Adjunct to D1250 from ASTM.
Need read-only mode for database access
	MySQL (cConnectMySQLDB ?) property ReadOnly, logical
	cModelID: exit the following methods when ReadOnly true: constructor, destructor, insertIntoTable, set methods
	When all tests pass in read-only mode, code is compatible with read-only DB
Tests:
	
loadBergeNoon: Fix bug where dates inserted with day field equal to 0.
cVessel.regressions: rename method to regression.
updateBrakePower: replace 24 hours with hours in service per record, limited to 25.
VesselDisplacement: table for relating vessel IMO to displacement model
BunkerDeliveryNote: make bdn independent of IMO_Vessel_Number
cModelID: when a model is updated from a script, the Name property must be assigned to first, otherwise the other values will be overwritten

cMID.Synched:
	Data different from that in DB
	When TRUE, delete data in DB before inserting new
	When FALSE, skip insert

cMID.set.Name / cMID.set.ModelID:
	set Synched to TRUE
	Check if data selected matches current data:
		no: issue warning that data overwritten
		
cTableObject : abstract class for reading and writing data between objects in MATLAB and tables in a database 
Move methods readFromTable and insertIntoTable from cMySql to cTO.
Inherit cV, cSP, cW, cD from cTO.
Extract method matchingFields from readFromTable.
Create listeners for all matchingFields of cTO implementation classes.
Inherit cMID from cTO.
When cMID calls readFromTable, have listeners check whether data overwrites different data, issue warning if so.

Process discrete speed, power data:
	# cVSP.testFit: compare results to those obtained from digitised plot image
	DB.SpeedPower: Replace digitised graph values with actual measurements from sea trial reports
	Integrate into HPDB interface:
		DB table for speed, power measurements
		Add speed power model page accepts only columns for speed, power, scalars for density, displacement, trim, drafts (optional combos of the last four)
		Return coefficients
		Plot fit (measurements, errors, displacement transformation)
		Assess fit
		
cModelID.SafeMode: default FALSE, when TRUE, error when change of Name causes change of data values
cModelID.ModelID: remove property?
cMID.set.Name:
	if Name changes
		if previous Name non-empty
		if cMID.data is empty or cMID.SafeMode is FALSE
			call cMID.eraseData
			assign data to matching fields
DB: make constraint where Name is Unique in each ModelType table
DB.Models: make constraint where Name, ModelType pairs are unique
cMID.insertIntoTable: error if obj.changePending returns TRUE and obj.SafeMode is TRUE

cTO.eraseData:
	get matchingFields
	iterate over matching fields, replace with empty/default value
cTO.changePending: TRUE when data in matchingFields not equal to data read from DB

# cModelName: rename from cModelID (after removing ModelID from properties)
# cV.iterateDD: provide developer with easy way to iterate DD intervals
cV.cV: allow for all cConnectMySQLDB properties input
cV.set.Database: apply Database field value to all nested cModels
cDB: create vesselWindModelTable

cVD.convert_: track and check current units against method call
DB: drop table vesselspeedpower, replace with column for sp model in Vessels table
cV.insertIntoSpeedPower: omit code writing into vesselspeedpower
cV.In-service: table with performance data by default, raw data when called
cVDDD: rename to cVDD?

the following cV methods need re-written to remove old dd indexing
	cV.DDPer
	cV.estimatedFuelConsumption
	
cV.powerIncreasePerCoating: remove method? seems redundant now we (soon will) have PowerBI comparing coatings
# cVesselParticulars: move properties from cV to cVP
# cV: all "report methods" should assign into/ read from "obj.Report"
# cV.iterateDD: return false if no data.

cV.Report: make all "report methods" output only the kind of structs returned by movingAverage.
cV.movingAverage: remove DryDockInterval from structure field (flat array of structs instead)
cV.movingAverage: have only scalar numeric values in each field
	cV.DryDockingPerformance: cV.Report.DDP: struct with fields StartDate, 
	EndDate, Average, Std etc which allow for plot to draw lines for every 
	value (ref, eval periods and vertical difference).
	
cV.set.AllModelProperty: IF model connection empty, copy connection from cV
cV.RawDataLoaded: logical scalar set to true after rawData called
cV.set.Database: delete InService, call performanceData, call rawData if requested
cMN.set.Database: close connection, attempt new connection with same credentials, copy to all obj in input array
Allow set of credentials to be "loaded" with one click after windows authentication?
cDB
	DNVGL.RawData: table matching contents of raw files downloaded from EcoInsight
	DNVGL.PerformanceData: table matching contents of perf files downloaded from EcoInsight
	Force.RawData: table matching contents of raw files downloaded from SeaTrend, without performance values
	Force.PerformanceData: table matching contents of perf files downloaded from EcoInsight, only performance values
# 	Static: all static ship data
	TestStatic: all static ship data
	Hempel: ISO-ready raw data, Hempel performance data, Analysis tables, constants and functions
	TestHempel: ISO-ready raw data, Hempel performance data, Analysis tables
cV.tradingParameters: gives values inconcsistent with speedHistogram for Euronav vessels (mean speed lower than median?)

Authentication
	cV.cV: ask for credentials
		shallow copy connection object to all nested objects
	cMID.set.Database:
		ask for credentials
		shallow copy connection object to all members of array

Change vessel identificiation to vessel config id from IMO
cMN: remove class
# cMID: just like cMN but with Name functionally replaced by Model_ID. Name no longer a property.
#	cModelID abstract class with abstract props FieldName, ModelTable, ValueTable, Column (to replace Type)
	cV inherits from cMID
		cV.ModelTable = 'Vessel', .ModelField = 'Vessel_Id'
		cV.ValueTable = {'VesselConfiguration', 'VesselInfo', 'BunkerDeliveryNote'}
			when IMO value assigned to cV.ModelID,
				cMID.set.MID reads OBJ data from all ValueTable
				for each cV property which is a cMID,
					assign _Model_Id value read from VesselConfiguration to .MID property
#	cVD inherits from cMID
#		cVD.ModelTable = 'DisplacementModel', .ModelField = 'Displacment_Model_Id', .ValueTable = 'Displacment_Model_Value'
#	cVSP inherits from cMID
#		cVSP.ModelTable = 'SpeedPowerCoefficientModel', .ModelField = 'Speed_Power_Coefficient_Model_Id', .ValueTable = 'Speed_Power_Coefficient_Model_Value'
#	cVWC inherits from cMID
#		cVWC.ModelTable = 'WindCoefficientModel', .ModelField = 'Wind_Coefficient_Model_Id', .ValueTable = 'Wind_Coefficient_Model_Value'
#			when IMO value assigned to cV.ModelID not in DB,
#				reserve value in ValueTable
#				if no values added, clear reserved value
				
cCMSQLDB.ReadOnly: set parameters of connection to read-only
cMN: rename to cMID
cMID.Name: remove prop
cMID.set.Name: replace all references to Name with Model_ID
cMID.set.MID: read any data from all ValueTable identified by Model_ID
cMID.set.MID: reserve Model_ID in ModelTable if not found and if ReadOnly is FALSE

cVesselEvent:
	cVE: an event with a defined start and end where performance values are statistically dissimilar before and after
	change cDDD to just cDD
	make superclass of cDD
	cHullCleaning, cConfigurationChange also sub class of cVE
	replace cV.cDDD with cV.Event: a cell array of event sub classes
	iterateDD becomes iterateEvent
	plotPerformanceData optionally reports event type (on second horiztontal axis, on top of graph?)
	
cVC: rename from current cV, new prop Vessel contains handles to cV class.
cVC.plotPerformanceData:
	assign from each vessel into corresponding graph
		iterateEvent
			get current DD for current VC
				use dates from and to for different configs
			return DDi, VCi, Vi
		plot into figure for current Vi data indexed by DDi, VCi
cVC.cVC('IMO', imo): return in cVC all the configuration data for the MOST 
	RECENT configuration for imo, and all previous configurations in prop 
	Previous.

cTO

applyFilters.sql: allow user to control filtering of speed through water values.
cV.FuelType: move property to cVE
cV.cV: initialise cV.Engine prop to "unknown" and default FuelType.
cDB.createStatic
	create static tables: vessel, sp, spc, spcvalue, wind, disp, vc
cDB.createHempel
	create DB with PerformanceData, RawData, Analysis, Constants tables, functions
cV.cV: assign Delegate database as default
cV.PerformanceTable (Hidden): string indicating table containing performance data
cV.PerformanceColumn (Hidden): cell/string indicating columns of performance data
cV.performanceTable(dbname): return performance table name for DBNAME
	if DBNAME = 'the delegate one', 'CalculatedData'
		DBNAME = 'DNVGL', 'PerformanceData'
		etc
	else
		'CalculatedData'
cV.updateNestedConnections: scalar logical indicating whether to copy connection object
	to nested cMID in properties of cV (default TRUE)
cV.set.Database:
	call performanceTable with new Database
	assign Database, PerformanceTable
	do connection, authentication steps
	if updateNestedConnections
		for all properties which are cMID
			copy connection object
			read data from new connection
			
# write sql script: BunkerDeliveryNote.rpt             '
write sql script: CalculatedData.rpt                 '
# write sql script: DisplacementModel.rpt              '
# write sql script: DisplacementModelValue.rpt         '
# write sql script: DryDock.rpt                        '
# write sql script: EngineModel.rpt                    '
write sql script: GeneratedISO19030Report.rpt        '
write sql script: ImportJob.rpt                      '
# write sql script: RawData.rpt                        '
# write sql script: SpeedPowerCoefficientModel.rpt     '
# write sql script: SpeedPowerCoefficientModelValue.rpt'
# write sql script: Vessel.rpt                     	 '
# write sql script: VesselConfiguration.rpt            '
# write sql script: VesselGroup.rpt                    '
# write sql script: VesselInfo.rpt                     '
# write sql script: VesselOwner.rpt                    '
# write sql script: VesselToVesselOwner.rpt            '
# write sql script: WindCoefficientModel.rpt           '
# write sql script: WindCoefficientModelValue.rpt  	 '

Split all insert_data scripts into model and time
Add all insert_model and insert_time scripts to cDB.runHempel
cCMYSQLDB: Figure out default DB
cWC.properties: remove, or implement for all cV_ classes?
cV.Name: make Name dependent, set value when Info added

To sync data between an object with a model table and multiple nested objects referencing same table:
	cV.IMO = imo:
		1. Find most recent configuration for imo, return corresponding Vessel_Id
		2. cV.Vessel_: call cMySQL.readFromTable(tab, 'vessel_id')
	cTO.readFromTable: as cMySQL
	cTO.checkModel(obj, table, field, mid): read out data if found, 
		increment model id otherwise (as cModelID.set.ModelID) 
		all input can be same size and corresponding elements will be taken 
		together, otherwise obj, field can be scalar and table cellstr and 
		obj will be assigned to from multiple table identified by same field
	cMID: inherit from cTO
	cMID.set.ModelID: extract method checkModel(obj, [{ModelTable}, ValueTable], ModelField) call checkModel on ModelTable and ValueTable
	cV: don't inherit from cMID, inherit from cTO
	cV.set.IMO(imo):
		cV.mostRecentConfiguration(imo)
		cV.checkModel on all sub-classes
	cMID.insertIntoModels: insert method into reserveModel?
	cTO.reserveModel: copy method from cMID, new input TABLE
	cTO.releaseModel: copy method from cMID, new input TABLE
	cMID.reserveModel, releaseModel: call with appropriate table

?alias_c = obj.propertyAlias;
?reserveModelID calls insertIntoTable
?cTO.Deleted
cVSP.insert:
	if mid empty, increment
	call cMID.insertIntoTable on sp, spcm, spcmv
cDateConvert: find how to have subclasses Start, End properties reflect DateFormStr always

# cMYSQL.cMYSQL: allow for Connection to be input
# cMYSQL.connect: check if any conn in Connections has input properties, index or create
# cV.cV: pass connection inputs to cMYSQL/cTableObject
# cV.set.DatabaseName: pass Connection to cVSP, cVD ... (all nested cMYSQL children)
# cV.cV: call assignDefaults after connection made
cTO.isempty: ignore properties in Props2Ignore, pass to cMYSQL.isempty
cDDD.Props2Ignore = 'DateStrFormat'

SpeedPowerModelValue table has many empty rows
	
%% What if we remove reserving/releasing?
	cTO are assigned to, inserted on insert command.
	cMID.set.ModelID: reads out data if ModelID found in ModelTable
	cVSP.insert:
		inserts into SpeedPowerCoefficientModel
					SpeedPowerCoefficientModelValue
					SpeedPowerModel				(if table exists)
					SpeedPowerModelValue		(if table exists)
					(cVSP could have new properties to describe SpeedPowerModel)
	cVSP.set.ModelID:
		checks SpeedPowerCoefficientModel
			if found, read out [Speed_Power_Coefficient_Model_Id] as ModelID
				read obj data from SpeedPowerCoefficientModel
				select all Model_Value_ID where ModelID
				read obj data from SpeedPower where Model_Value_ID
				
	cVWC.set.ModelID:
		read out data if ModelID found in ModelTable
	cVWC.insert: insert into ModelTable and ValueTable
	
	ACTIONS
	# Remove methods cMID.reserveModelID, cMID.releaseModelID, cMID.delete
	# Move cTO.checkModel to cMID.checkModel
	# Rename cMID.checkModel to cMID.readFromTable
	# Rename method cMID.insertModel to .insert
	# Rename cTO.insertIntoTable to insert
	# Rename cV.insertIntoTable to insert
	# cTO.readFromTable: return unmodified object if identifier value not found (also return flag indicating such)
	# Remove method cMID.isModelInDB
	# Rename method cTO.readFromTable to cTO.select
	# cMID.insert:
	#	if ModelID empty, increment
	#	insert into ModelTable, ValueTables
	#cMID.set.ModelID
	#	if ModelID found in DB, read obj data from ModelTable and ValueTables
			call cMID.readOthersIfExist(
	#	else assign
	# cV < cMID
	# cV.ModelTable = 'Vessel';
	# cV.ModelField = 'Vessel_Id';
	# cV.ValueTable = {'VesselConfiguration', 'VesselInfo', 'BunkerDelivery'};
	#Test with cVessel
	#cMID.OtherTable
	#cMID.OtherTableIdentifier
	#cMID.readOthersIfExist(obj)
	#	call obj.readFromTable on .OtherTable with .OtherTableIdentifier iff .OtherTable exists
	#Test with cVSP
Remove Vessel_Id field from VesselOwner table
Implement VesselOwner select/insert.

User creates cV
	cV.cVC has empty Speed_Power_Coefficient_Model_Id
	cVC.insert will error because Speed_Power_Coefficient_Model_Id cannot be NULL in DB
User assigns data to cV.SP props
	User calls cV.insert
		cVSP inserts into all tables (otherTable)
		cTO.insert returns object with all data read out from DB (including any auto-incremented values)
			(rename to cTO.sync ?)
		cVSP has new Speed_Power_Coefficient_Model_Id value
		cV assigns cVSP.Speed_Power_Coefficient_Model_Id into cVC.Speed_Power_Coefficient_Model_Id
cVC.Vessel (Hidden): prop storing corresponding vessel handle
User assigns cV.Configuration.Speed_Power_Coefficient_Model_Id = id
	cVC.set.Speed_Power_Coefficient_Model_Id:
		cheap SQL hack to get all [Speed_Power_Coefficient_Model_Value_Id] for this id
		create cVSP vector with input ModelID found from above
		assign vector into cV.cVSP

# Make Speed_Power_Coefficient_Model_Id in VesselConfiguration non NULL
cTO.TableIdentifier: char that would be passed to cTO.select as IDENTIFIER
Write cTO.select call into cTO.insert
	both apply only to DataProperty of object
	THIS REQUIRES cTO.SELECT TO RETURN OBJ (NO ERROR) WHEN IDENTIFIER DATA NOT FOUND
cV.insert: assign cVSP.Speed_Power_Coefficient_Model_Id into cVC.Speed_Power_Coefficient_Model_Id after acquiring value from DB
# cVSP.incrementSPModel: add 1 to maximum value of Speed_Power_Coefficient_Model_Id in DB table and assign to all elements of array
# cVSP.insert: call cVSP.incrementSPModel if property empty
# cMID.ModelField: if scalar, cMID.insert will repeat to length of ValueTable plus one
cTO.PropertyAlias: DB field names corresponding to DataProperty names
cVC.VesselConfigurationDescription: make property alias to Description (or Name)
DB.SpeedPower: remove Disp, Trim
DB.VesselConfig: make all model_id fields required non null
testcVessel: test cases where nested objects are empty
cV.set: set access methods for all nested objects
cTableObject.lastInsertID: return the last auto-incremented identifier value
# cTO.insert:
#	if obj.Identifier is empty
#		call id = cTableObject.lastInsertID;
#		insert id into additionalInputs
#	call obj.select
testcVessel: Test both cases where modelID is either given or not
While Model_ID is only identifying value for any cMID, and Model_ID can be input empty, Model_ID must be specified explicitly in scripts
cTO.isequal(a, b): iterate over DataProperty and compare, true if all equal
cV.cV: rename input property Database to DatabaseName 
cVSP can insert, but how to read?
	Needs spmID before mID. Must come from cVC.
	cVSP.readSuper(spmID)
		call cTO.select on super table, get spmvID
		if cVSP empty, expand array to number of spmvID found
		elseif cVSP same size as spmvID found, assign
		else error
	Acquire spmID from current cMID select call inputs ?
		cVSP requires spmID before it can get Model_ID
		
cVSP.insert:
	calls cTO.insert into super-table
		cTO calls select, 
		could work if cModelID.select reached
cVSP.selectSuper:
	needs to call cVSP.select, not cTO.select
	needs spmID, from somewhere.
		If not in prop, return
cVSP.insert:
	needs to insert into super first
		then into model and value
	needs cTO.insert calls to call select, to get all incremented values
	needs cVSP.select to select from all tables at identifiers used to insert
cVSP.select:
	if spmid empty, return
	select from all tables at identifiers input from insert call
		select from super table if spmid non-empty
		select from model table if spmvid non-empty
		select from value table if spmvid non-empty
		
	Process:
		cVSP.insert:
			inserts into super
				gets id from last_inserted_id
				calls select with last_inserted_id
			selects from super
				returns
			inserts into model
				calls select with last_inserted_id
			selects from model AND value
			inserts into value
				calls select with last_inserted_id
			selects from model AND value
			
		cV.set.IMO:
		CASE 1: cV.SP empty before
			 if cVC.spmID non-empty
				assign smpID into cVSP
				assign fieldname, smpID into appropriate elements of inputs
				call cVSP.select(inputs) (expand array to size, assign super values)
				call cVSP.select(inputs) again (assign model values)
		CASE 2: cV.SP non-empty before
				assign smpID into cVSP
				assign fieldname, smpID into appropriate elements of inputs
				call cVSP.select(inputs) (expand array to size, assign super values)
				call cVSP.select(inputs) again (assign model values)
		
include cMID.incrementModelID in cMID.insert
cTO.select(..., identifier, ...: make an optional input indicating rows of any found table identifying each object for which data is assigned
cTO.select(..., whereField_c,...: optional parameter value pairs to indicate part of table where object data found
# cTSQL: class to generate t-sql statements inherites from cSQL
# cSQL: abstract class for generating SQL statements with abstract methods select, ...
# cMySQL: inherit from cSQL
# cVessel: new (hidden) property SQL containing a cSQL, replaces all former calls to cMySQL methods from OBJ
#	cTO doesn't know which SQL to create from inputs yet
#	Can have standard set of credentials (no password), together with SQL implementation?
#		conn = savedConnections('Database', 'hullperformance') returns in conn inputs 
#		needed to connect with cCMYSQLDB. Data stored in script.
#	savedConnections called by cMID constructor, returning cSQL sub-class
#	cTO assigns cSQL to property SQL
#cCMYSQLDB.savedConnections: return input cell and cSQL from database name
#SavedConnections: script with saved connnections
	Error "Field 'Speed_Power_Coefficient_Model_Id' doesn't have a default value" at testVessel.insert;
	Seems that cModelID.insert or matchingFields isn't writing in the additional data required by the table, which was happening on the work laptop.
# $ Attempt connection to hullperformance through cVessel again (Works! apart from DryDock property)
$ Verify read only mode working on hullperformance
Write testcVessel.testselectRaw:
	test that all raw data read when called without inputs
	test that multiple calls with smae inputs do not generate duplicate columns or rows
	test with input dateFrom, dateTo
	test with input Cols
EXTRACT METHODS FROM CVESSEL TO CVESSELANALYSIS
WRITE MATLAB WRAPPERS TO MYSQL ISO19030 PROCEDURES
cVSP: make ValueTable SpeedPower optional part of inserting, selecting data
cV.selectInService: method currently uses different datestring format than obj.DateFormStr. Need way to make adodb return desired format.
cSQL.tableFromQueryResult: convert cell cols to numerical columns where possible
cV.set.IMO: check if multiplie cVSP being read from hullperformance
cV.set.IMO: cVDD not being read from hullpeformance 
cTO: try removing TableIdentifier
cTO: try removing ModelField
cTO.select(tab, objID, alias, whereFields, whereVals)
	objID: property/field name identifying all data in query belonging to this OBJ
	alias: cell of property alias names
	whereFields, whereVals: property/field name and values identifying data in DB belonging to this OBJ array
	
Can "additionalFields" just be used to identify obj array data in DB?
	Assume that any additionalFields identify the array
	Make whereValueInput redundant
	Have objID and whereFields by "select table" step
		If additionalFields input, whereFields = additionalFields
		else whereFields = objID
	Use whereFields in select statement
	Use objID to identify each OBJ within query results
Make order of cV.DD irrelevant? (currently DDIntervalsFromDates needs chronological)
cV.Configuration: currently allows more than one configuration. Need solution for "previous configurations" to be kept in some property. cV code currently expects one Config.
	
		
	







































